<html>
<head>
<meta charset="utf-8">

</head>
<body>
    <style>
    </style>

    <script type="text/front-matter">
        title: "AN INTRODUCTION TO ALPHA ZERO THAT I WILL NAME UPON A LATER DATE"
        description: "Description of the post"
        authors:
        - Josh Varty: http://joshvarty.com
        affiliations:
        - None  : http://joshvarty.com
      </script>
      
      <dt-article>
        <h1>Alpha Zero</h1>
        <h2>Four out of five dentists agree that this is absolute most basic introduction to AlphaZero and Monte Carlo Tree Search ever produced by the human race.</h2>
        <dt-byline></dt-byline>


        <h2>A simpler game</h2>

        <p>
          Go has ~2.08x10<sup>170</sup> legal board positions. Chess has ~10<sup>50</sup> legal board positions. Even Tic-Tac-Toe has 5,478 legal board positions.
          If we're going to have any hope of understanding AlphaZero and MCTS for the first time, we're going to need a simpler game.

          We need a comically simple game that still allows for wins, losses and draws.
        </p>

          <p>Ladies and gentlemen, for your consideration: Connect2!</p>
        </p>
        <figure id="value-network" style="width:100%;margin:0;background:#000b2a;padding:25px 0;">
          <img style="max-width:300px; display:block; margin:0 auto;" src="connect2.gif" />
        </figure>

        <p>
          In Connect2 players alternate between playing pieces on a tiny <code>1x4</code> board with the goal of placing two of their pieces side-by-side. 
          It's comically easy to win as the first player, but Connect2 still has the interesting property that either player technically has the chance to win, lose or draw. 
          This means we can use it as a test bed to debug and visualize a super-basic implementation of AlphaZero and Monte Carlo Search Trees.
        </p>

        <p>
          Below is the complete game tree of all possible Connect2 games:
        </p>

        <figure id="tree" style="height:600px;width:100%;margin:0;background:#000b2a">
          <svg style="background:#000b2a; margin: 0 auto; display:block; width:1700px; height:500px; padding-top:25px;"></svg>
        </figure>

        <p>
          In total, there are 24 terminal states. From Player 1's perspective there are:
          <ul>
            <li>12 terminal states where we WIN</li>
            <li>8 terminal states where we LOSE</li>
            <li>4 terminal states where we DRAW</li>
          </ul>          
        </p>

        <h4>Representing the Game</h4>
        <p>One drawback of AlphaZero is that we need to be able to perfectly simulate the game. This ends up being relatively straightforward for Connect2 but 
          is much more difficult for games like chess that have more complex rules. The full code for Connect2 is available <a href="https://github.com/JoshVarty/AlphaZeroSimple/blob/ecf72a468aba26b8b155ec6fb1b91697a2fbb7a9/game.py">on GitHub</a>. It contains logic that defines 
          what moves are valid, how to transition between states and what reward a player should receive.
        </p>
        <p>
          In our implementation we're going to represent a player's own pieces with <code>1</code>, their opponent's pieces with <code>-1</code> and an empty space as <code>0</code>. So the initial starting state looks like <code>[0,0,0,0]</code>. The player who wins the game will receive a reward of <code>1</code> and the player who loses will receive <code>-1</code>. Draws will receive a reward of <code>0</code>.
        </p>
        <p><strong>Note:</strong> There is a very important detail here: The player who is playing always sees <em>their own</em> pieces as <code>1</code>. In our implementation, we simply multiply the board by <code>-1</code> every time we transition between players. Below, observe that state "toggles" as players take turns placing pieces:</p>

        <figure id="treeWithStates" style="height:600px;width:100%;margin:0;background:#000b2a">
          <svg style="background:#000b2a; margin: 0 auto; display:block; width:1700px; height:500px; padding-top:25px;"></svg>
        </figure>
        <hr>

        <h2>Alpha Zero</h2>

        <p>At its core, AlphaZero is built from three core pieces:
          <ol>
          <li>Value Network</li>
          <li>Policy Network</li>
          <li>Monte Carlo Tree Search  </li>
          </ol>
        </p>

        <h3>Value Network</h3>

        <p>
          The value network accepts a board state as input and gives us a score as output. If we are going to win with absolute certainty, we want our value network to output <code>1</code>. If we are going to lose, we want our value network to output <code>-1</code>. If we are going to draw, we want our value network to output <code>0</code>.
        </p>

        <p>For example, the game below is guaranteed to be a tie, so we'd like our network to produce 0 (or something close to it).</p>

        <figure id="value-network" style="width:100%;margin:0;background:#000b2a">
            <img style="max-width:700px;display:block;margin:0 auto" src="value_net.png" />
        </figure>

        <p>There are some subtleties here worth discussing. First off, our network isn't doing any "thinking" to produce a value. That is, it's not looking ahead, considering all possible moves or anything like that.
          It's esssentially acting as an image classifier. In fact for 2D games like Go, we would borrow computer vision architectures like ResNet and use them as the backbone for our networks.
        </p>

        <p>
          For AlphaZero, we train this network by playing many games, recording the moves both players took along with the winner and training the network to output <code>1</code> for all the games we won, and <code>-1</code> for all the games we lost.

          The dataset might look like
        </p>

        
        <pre style="margin-left: calc(50% - 984px / 2);width: 648px;">[ 0  0  0  0] [ 1]
[-1  0  0  0] [-1]
[ 1  0 -1 -1] [ 1]</pre>


        <p>
          It's our hope that over a long enough time horizon, our value network will become increasingly good at identifying "good" states. This ends up being important
          as it will help guide our Monte Carlo Tree Search later.
        </p>

        
        <h3>Policy Network</h3>
        <p>
          The policy network accepts a board state as input and gives us a set of probabilities for each move as output. The "better" the move, the higher we would like the probability for the corresponding position.
          The role of the policy network is to "guide" our Monte Carlo Tree search by suggesting promising moves. The Monte Carlo Tree Search takes these suggestions and digs deeper 
          into the games that they would create (more on that later).
        </p>
        <p>We call the suggestions produced by the policy network "priors".</p>
        <p>For example, the game below can be won in a single move, so we'd like our network to confidently suggest that we play in the first position:</p>

        <figure id="value-network" style="width:100%;margin:0;background:#000b2a; padding-top:15px;" >
            <img style="max-width:795px;display:block;margin:0 auto" src="policy_net.png" />
        </figure>

        <p>Note that our network often gives non-zero probabilities to illegal moves. Above, our network gives 0.01 to the second and third slots.
          We actually have to correct for this manually by masking out illegal moves, and then re-normalizing the remaining scores so they still sum to a probability of 1.00.
        </p>
        <p>
          Like the value network, our policy network is not doing any kind of "deep thinking" or lookahead. In fact it's more comparable to something like a human playing bullet chess. 
          It's simply making a snap decision based on the current state of the board. 
        </p>

        <figure id="value-network" style="width:100%;margin:0;background:#000b2a; padding-top:0px;" >
          <img style="display: block; margin:0 auto; max-width:25%;" src="bulletchess.gif" />
        </figure>

        <h4>Training</h4>
        <p>
          One counter-intutive thing about AlphaZero is that we don't train our policy network to be "better". Instead we train it to mimic the output of the Monte Carlo Tree Search.
          As we play games, the policy network suggests moves to Monte Carlo Tree Search. MCTS uses these suggetsions (or priors) to explore the game tree and returns a (hopefully) better
          set of probabilities for a given state.

          We record the state and the probabilities produced by the MCTS. At training time we train our policy network to output similar moves using Cross Entropy Loss.
        </p>

        <h3>Monte Carlo Tree Search</h3>

        <p>Despite the outside world's focus on the neural networks involved in AlphaZero, the true magic of AlphaZero comes from Monte Carlo Tree Search. It's here 
          that AlphaZero simulates moves and looks ahead to explore a range of promising moves.
        </p>


      </dt-article>

      
      <dt-appendix>
      </dt-appendix>
      
      <script type="text/bibliography">
        @article{gregor2015draw,
          title={DRAW: A recurrent neural network for image generation},
          author={Gregor, Karol and Danihelka, Ivo and Graves, Alex and Rezende, Danilo Jimenez and Wierstra, Daan},
          journal={arXivreprint arXiv:1502.04623},
          year={2015},
          url={https://arxiv.org/pdf/1502.04623.pdf}
        }
      </script>

    <script src="https://distill.pub/template.v1.js"></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>

    <script>

      class Node {
        constructor(x, y, state, parent, toPlay) {
          this.x = x;
          this.y = y;
          this.state = state;
          this.parent = parent
          this.children = []
          this.toPlay = toPlay

          if (this.parent != null) {
            this.parent.children.push(this);
          }
        }
      }

       const kPath = `M78.3,96.5c-0.1,0.4-0.5,0.6-1.1,0.6H64.9c-0.7,0-1.4-0.3-1.9-1l-20.3-26L37,75.5v20.1 c0,0.9-0.5,1.4-1.4,1.4H26c-0.9,0-1.4-0.5-1.4-1.4V3.9c0-0.9,0.5-1.4,1.4-1.4h9.5C36.5,2.5,37,3,37,3.9v56.5l24.3-24.7 c0.6-0.6,1.3-1,1.9-1H76c0.6,0,0.9,0.2,1.1,0.7c0.2,0.6,0.1,1-0.1,1.2l-25.7,25L78,95.1C78.4,95.5,78.5,95.9,78.3,96.5z`;
       const goose1Path = `M8.8,92.7c-4-18.5,4.7-37.2,20.7-46.2c0,0,2.7-1.4,3.4-1.9c2.2-1.6,3-2.1,3-5c0-5-2.1-7.2-2.1-7.2 c-3.9-3.3-6.3-8.2-6.3-13.7c0-10,8.1-18.1,18.1-18.1s18.1,8.1,18.1,18.1c0,6-1.5,32.7-2.3,38.8l-0.1,1`;
       const goose2Path = `M27.4,19L8.2,27.6c0,0-7.3,2.9,2.6,5c6.1,1.3,24,5.9,24,5.9l1,0.3`;
       const goose3Path =  `M63.7,99.6C52.3,99.6,43,90.3,43,78.9s9.3-20.7,20.7-20.7c10.6,0,34.4,0.1,35.8,9`;

      function placeEdges(containerId, node) {

        for (var i = 0; i < node.children.length; i++) {

          //Recursively place edges
          placeEdges(containerId, node.children[i]);

          //Draw edge for this child
          let x1 = node.x + 32
          let y1 = node.y + 25
          let x2 = node.children[i].x + 32
          let y2 = node.children[i].y - 15

          placeLine(containerId, x1, y1, x2, y2);
        }
      }

      function placeEmptySlot(container, x, y) {

        container
          .append('svg')
          .attr('x', x)
          .attr('y', y)
          .append('circle')
          .attr('cx', 80)
          .attr('cy', 80)
          .attr('r', 75)
          .attr('fill', 'rgba(0, 255, 255, 0)')
          .attr('stroke', '#0358a4')
          .attr('stroke-width', '13')
      }

      function placeGoosePiece(container, x, y) {
        let svg = container
            .append('svg')
            .attr('x', x)
            .attr('y', y)


        // outer circle
        svg.append('circle')
            .attr('cx', 80)
            .attr('cy', 80)
            .attr('r', 75)
            .attr('fill', 'rgba(255, 255, 255, 0.5)')
            .attr('stroke', 'rgba(255, 255, 255, 0.5)')
            .attr('stroke-width', '3')
        
        // inner circle
        svg.append('circle')
            .attr('cx', 80)
            .attr('cy', 80)
            .attr('r', 60)
            .attr('fill', 'none')
            .attr('stroke', 'rgba(255, 255, 255, 0.5)')
            .attr('stroke-width', '2')

        // goose
        var goose = svg.append('svg').attr('stroke', 'black').attr('fill', 'rgba(0,0,0,0)');
        goose.append('path')
          .attr('d', goose1Path)
          .attr('stroke', 'rgba(255, 255, 255, 1)')
          .attr('stroke-width', '2')
        goose.append('path')
          .attr('d', goose2Path)
          .attr('stroke', 'rgba(255, 255, 255, 1)')
          .attr('stroke-width', '2')
        goose.append('path')
          .attr('d', goose3Path)
          .attr('stroke', 'rgba(255, 255, 255, 1)')
          .attr('stroke-width', '2')
        goose.attr('x', '35')
        goose.attr('y', '35') 
      }

      function placeKagglePiece(container, x, y) {
        // Build the kaggle game piece logo and place inside SVG

        let svg = container
          .append('svg')
          .attr('x', x)
          .attr('y', y)

        // outer circle
        svg.append('circle')
            .attr('cx', 80)
            .attr('cy', 80)
            .attr('r', 75)
            .attr('fill', 'rgba(0, 255, 255, 0.5)')
            .attr('stroke', 'rgba(0, 255, 255, 0.5)')
            .attr('stroke-width', '3')

        // inner circle
        // outer circle
        svg.append('circle')
            .attr('cx', 80)
            .attr('cy', 80)
            .attr('r', 60)
            .attr('fill', 'none')
            .attr('stroke', 'rgba(0, 255, 255, 0.5)')
            .attr('stroke-width', '2')

        // kaggle logo
        var kaggle = svg.append('svg')
            .attr('stroke', 'black')
            .attr('fill', 'rgba(0,0,0,0)')
            .attr('viewBox', '0 0 100 100')
            .attr('height', '80')
            .attr('width', '80')

        kaggle.append('path')
            .attr('d', kPath)
            .attr('stroke', 'rgba(0, 255, 255, 1)')
            .attr('stroke-width', '2')
            .attr('scale', '0.6')
        kaggle.attr('x', '40')
        kaggle.attr('y', '40') 
      }

      function placeLine(containerId, x1, y1, x2, y2) {
        let container = d3.select(containerId)
          .append('line')
          .attr('x1', x1)
          .attr('y1', y1)
          .attr('x2', x2)
          .attr('y2', y2)
          .attr('stroke', 'rgba(255, 255, 255, 0.5')
      }


      function placeBoard(containerId, node, height, width, showStates) {

        let container = d3.select(containerId)
        .append('g')

        let svg = container
          .append('svg')
          .attr('height', height)
          .attr('width', width)
          .attr('viewBox', "0 0 672 160")
          .attr('style', 'background:#000b2a')
          .attr('x', node.x)
          .attr('y', node.y)

          if (showStates) {

            console.log(node)
            let text = "["
            for(var i = 0; i < node.state.length; i++) {
              text = text + " " + node.state[i] * node.toPlay;
            }
            text = text + "]";

            container.append("text")
            .attr('font-family', 'Arial,"Helvetica Neue",Helvetica,sans-serif')
            .attr('font-size', '0.8rem')
            .attr('x', node.x + 6)
            .attr('y', node.y - 4)
            .attr('fill', "white")
            .text(text)
          }

          let margin = 10
          placeEmptySlot(svg, 0,   0);
          placeEmptySlot(svg, 160 + margin, 0);
          placeEmptySlot(svg, 320 + margin + margin, 0);
          placeEmptySlot(svg, 480 + margin + margin + margin, 0);

          let xOffset = 0
          let yOffset = 0
          for(let i = 0; i < node.state.length; i++) {
            if (node.state[i] == 1) {
              placeKagglePiece(svg, xOffset, yOffset)
            } else if (node.state[i] == -1) {
              placeGoosePiece(svg, xOffset, yOffset)
            }

            xOffset = xOffset + 160 + margin
          }
      }

      function drawTree(containerId, showStates) {
        let width = 1700

        let boardHeight = 15;
        let boardWidth = 63;

        let y = 25;
        let root = new Node(860-32, y, [0,0,0,0], null, 1)
        placeBoard(containerId, root, boardHeight, boardWidth, showStates)

        y = 125
        let r1c1 = new Node(2*1700/12/2, y, [1,  0,  0,  0], root, -1)
        let r1c2 = new Node(9*1700/12/2, y, [0,  1,  0,  0], root, -1)
        let r1c3 = new Node(14*1700/12/2, y, [0,  0,  1,  0], root, -1)
        let r1c4 = new Node(21*1700/12/2, y, [0,  0,  0,  1], root, -1)
        placeBoard(containerId, r1c1, boardHeight, boardWidth, showStates)
        placeBoard(containerId, r1c2, boardHeight, boardWidth, showStates)
        placeBoard(containerId, r1c3, boardHeight, boardWidth, showStates)
        placeBoard(containerId, r1c4, boardHeight, boardWidth, showStates)

        y = 225
        let r2c1 = new Node(1*1700/12/2/2, y, [1, -1,  0,  0], r1c1, 1)
        let r2c2 = new Node(4*1700/12/2/2, y, [1,  0, -1,  0], r1c1, 1)
        let r2c3 = new Node(7*1700/12/2/2, y, [1,  0,  0, -1], r1c1, 1)
        placeBoard(containerId, r2c1, boardHeight, boardWidth, showStates)
        placeBoard(containerId, r2c2, boardHeight, boardWidth, showStates)
        placeBoard(containerId, r2c3, boardHeight, boardWidth, showStates)
        
        let r2c4 = new Node(14*1700/12/2/2, y, [-1,  1,  0,  0], r1c2, 1)
        let r2c5 = new Node(17*1700/12/2/2, y, [ 0,  1, -1,  0], r1c2, 1)
        let r2c6 = new Node(20*1700/12/2/2, y, [ 0,  1,  0, -1], r1c2, 1)
        placeBoard(containerId, r2c4, boardHeight, boardWidth, showStates)
        placeBoard(containerId, r2c5, boardHeight, boardWidth, showStates)
        placeBoard(containerId, r2c6, boardHeight, boardWidth, showStates)
        
        let r2c7 = new Node(26*1700/12/2/2, y, [-1,  0,  1,  0], r1c3, 1)
        let r2c8 = new Node(29*1700/12/2/2, y, [ 0, -1,  1,  0], r1c3, 1)
        let r2c9 = new Node(32*1700/12/2/2, y, [ 0,  0,  1, -1], r1c3, 1)
        placeBoard(containerId, r2c7, boardHeight, boardWidth, showStates)
        placeBoard(containerId, r2c8, boardHeight, boardWidth, showStates)
        placeBoard(containerId, r2c9, boardHeight, boardWidth, showStates)
        
        let r2c10 = new Node(39*1700/12/2/2, y, [-1,  0,  0,  1], r1c4, 1)
        let r2c11 = new Node(42*1700/12/2/2, y, [ 0, -1,  0,  1], r1c4, 1)
        let r2c12 = new Node(45*1700/12/2/2, y, [ 0,  0, -1,  1], r1c4, 1)
        placeBoard(containerId, r2c10, boardHeight, boardWidth, showStates)
        placeBoard(containerId, r2c11, boardHeight, boardWidth, showStates)
        placeBoard(containerId, r2c12, boardHeight, boardWidth, showStates)

        y = 325
        let r3c1 = new Node(0*1700/12/2/2, y, [ 1, -1,  1,  0], r2c1, -1)
        let r3c2 = new Node(2*1700/12/2/2, y, [ 1, -1,  0,  1], r2c1, -1)
        placeBoard(containerId, r3c1, boardHeight, boardWidth, showStates)
        placeBoard(containerId, r3c2, boardHeight, boardWidth, showStates)
        
        let r3c3 = new Node(4*1700/12/2/2, y, [ 1,  1, -1,  0], r2c2, -1)
        let r3c4 = new Node(6*1700/12/2/2, y, [ 1,  0, -1,  1], r2c2, -1)
        placeBoard(containerId, r3c3, boardHeight, boardWidth, showStates)
        placeBoard(containerId, r3c4, boardHeight, boardWidth, showStates)

        let r3c5 = new Node(8*1700/12/2/2, y,  [ 1,  1,  0, -1], r2c3, -1)
        let r3c6 = new Node(10*1700/12/2/2, y, [ 1,  0,  1, -1], r2c3, -1)
        placeBoard(containerId, r3c5, boardHeight, boardWidth, showStates)
        placeBoard(containerId, r3c6, boardHeight, boardWidth, showStates)
        
        let r3c7 = new Node(12*1700/12/2/2, y, [-1,  1,  1,  0], r2c4, -1)
        let r3c8 = new Node(14*1700/12/2/2, y, [-1,  1,  0,  1], r2c4, -1)
        placeBoard(containerId, r3c7, boardHeight, boardWidth, showStates)
        placeBoard(containerId, r3c8, boardHeight, boardWidth, showStates)
        
        let r3c9  = new Node(16*1700/12/2/2, y, [ 1,  1, -1,  0], r2c5, -1)
        let r3c10 = new Node(18*1700/12/2/2, y, [ 0,  1, -1,  1], r2c5, -1)
        placeBoard(containerId, r3c9, boardHeight, boardWidth, showStates)
        placeBoard(containerId, r3c10, boardHeight, boardWidth, showStates)
        
        let r3c11 = new Node(20*1700/12/2/2, y, [ 1,  1,  0, -1], r2c6, -1)
        let r3c12 = new Node(22*1700/12/2/2, y, [ 0,  1,  1, -1], r2c6, -1)
        placeBoard(containerId, r3c11, boardHeight, boardWidth, showStates)
        placeBoard(containerId, r3c12, boardHeight, boardWidth, showStates)
        
        let r3c13 = new Node(24*1700/12/2/2, y, [-1,  1,  1,  0], r2c7, -1)
        let r3c14 = new Node(26*1700/12/2/2, y, [-1,  0,  1,  1], r2c7, -1)
        placeBoard(containerId, r3c13, boardHeight, boardWidth, showStates)
        placeBoard(containerId, r3c14, boardHeight, boardWidth, showStates)
        
        let r3c15 = new Node(28*1700/12/2/2, y, [ 1, -1,  1,  0], r2c8, -1)
        let r3c16 = new Node(30*1700/12/2/2, y, [ 0, -1,  1,  1], r2c8, -1)
        placeBoard(containerId, r3c15, boardHeight, boardWidth, showStates)
        placeBoard(containerId, r3c16, boardHeight, boardWidth, showStates)
        
        let r3c17 = new Node(32*1700/12/2/2, y, [ 1,  0,  1, -1], r2c9, -1)
        let r3c18 = new Node(34*1700/12/2/2, y, [ 0,  1,  1, -1], r2c9, -1)
        placeBoard(containerId, r3c17, boardHeight, boardWidth, showStates)
        placeBoard(containerId, r3c18, boardHeight, boardWidth, showStates)
        
        let r3c19 = new Node(36*1700/12/2/2, y, [-1,  1,  0,  1], r2c10, -1)
        let r3c20 = new Node(38*1700/12/2/2, y, [-1,  0,  1,  1], r2c10, -1)
        placeBoard(containerId, r3c19, boardHeight, boardWidth, showStates)
        placeBoard(containerId, r3c20, boardHeight, boardWidth, showStates)
        
        let r3c21 = new Node(40*1700/12/2/2, y, [ 1, -1,  0,  1], r2c11, -1)
        let r3c22 = new Node(42*1700/12/2/2, y, [ 0, -1,  1,  1], r2c11, -1)
        placeBoard(containerId, r3c21, boardHeight, boardWidth, showStates)
        placeBoard(containerId, r3c22, boardHeight, boardWidth, showStates)
        
        let r3c23 = new Node(44*1700/12/2/2, y, [ 1,  0, -1,  1], r2c12, -1)
        let r3c24 = new Node(46*1700/12/2/2, y, [ 0,  1, -1,  1], r2c12, -1)
        placeBoard(containerId, r3c23, boardHeight, boardWidth, showStates)
        placeBoard(containerId, r3c24, boardHeight, boardWidth, showStates)

        y = 425
        let r4c1 = new Node(0*1700/12/2/2, y, [ 1, -1,  1, -1], r3c1, -1)
        let r4c2 = new Node(2*1700/12/2/2, y, [ 1, -1, -1,  1], r3c2, -1)
        placeBoard(containerId, r4c1, boardHeight, boardWidth, showStates)
        placeBoard(containerId, r4c2, boardHeight, boardWidth, showStates)

        let r4c3 = new Node(6*1700/12/2/2, y, [ 1, -1, -1,  1], r3c4, 1)
        placeBoard(containerId, r4c3, boardHeight, boardWidth, showStates)

        let r4c4 = new Node(10*1700/12/2/2, y, [ 1, -1,  1, -1], r3c6, 1)
        placeBoard(containerId, r4c4, boardHeight, boardWidth, showStates)

        let r4c5 = new Node(14*1700/12/2/2, y, [-1,  1, -1,  1], r3c8, 1)
        placeBoard(containerId, r4c5, boardHeight, boardWidth, showStates)

        let r4c6 = new Node(18*1700/12/2/2, y, [-1,  1, -1,  1], r3c10, 1)
        placeBoard(containerId, r4c6, boardHeight, boardWidth, showStates)

        let r4c7 = new Node(28*1700/12/2/2, y, [1, -1,  1, -1], r3c15, 1)
        placeBoard(containerId, r4c7, boardHeight, boardWidth, showStates)

        let r4c8 = new Node(32*1700/12/2/2, y, [ 1, -1,  1, -1], r3c17, 1)
        placeBoard(containerId, r4c8, boardHeight, boardWidth, showStates)

        let r4c9 = new Node(36*1700/12/2/2, y, [-1,  1, -1,  1], r3c19, 1)
        placeBoard(containerId, r4c9, boardHeight, boardWidth, showStates)

        let r4c10 = new Node(40*1700/12/2/2, y, [ 1, -1, -1,  1], r3c21, 1)
        placeBoard(containerId, r4c10, boardHeight, boardWidth, showStates)

        let r4c11 = new Node(44*1700/12/2/2, y, [ 1, -1, -1,  1], r3c23, 1)
        let r4c12 = new Node(46*1700/12/2/2, y, [-1,  1, -1,  1], r3c24, 1)
        placeBoard(containerId, r4c11, boardHeight, boardWidth, showStates)
        placeBoard(containerId, r4c12, boardHeight, boardWidth, showStates)

        // Place edges
        placeEdges(containerId, root)
      }

      function drawCircle(containerId, x, y) {

        let circle = d3.select(containerId)
          .append('circle')
          .attr('cx', x)
          .attr('cy', y)
          .attr('r', 20)
          .attr('fill', '#000b2a')
          .attr('stroke', 'rgba(255, 255, 255, 0.8)')
          .attr('stroke-width', '1')
      }

      function placeArrow(containerId, x1, y1, x2, y2) {

        d3.select(containerId).append("svg:defs").append("svg:marker")
          .attr("id", "triangle")
          .attr("refX", 6)
          .attr("refY", 6)
          .attr("markerWidth", 30)
          .attr("markerHeight", 30)
          .attr("orient", "auto")
          .append("path")
          .attr("d", "M 0 0 12 6 0 12 3 6")
          .style("fill", "black");

      }

      let showStates = false;
      drawTree("#tree svg", showStates);

      showStates = true;
      drawTree("#treeWithStates svg", showStates)
      





      // x = 1700/12/2/2;
      // y = 200
      // for (let i = 0; i < 12; i++) {
      //   placeEmptyBoard(containerId, x, y)
      //   x = x + 1700/12;
      // }
      
      // x = 0
      // y = 300
      // for (let i = 0; i < 24; i++) {
      //   placeEmptyBoard(containerId, x, y)
      //   x = x + 1700/24;
      // }

    </script>
</body>
</html>